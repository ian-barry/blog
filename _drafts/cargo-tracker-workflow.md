---
layout: post
title: Cargo Tracker Workflow
---

### Cargo Tracker Workflow

`Bounded context: Shipping`

```text
Bounded context: Shipping
Workflow: "Book Cargo"
    triggered by:
        "Book Cargo" command
    primary input:
        "Book Cargo Form"
    other input:
        "Location" lookup
    output events:
        "Cargo Booked" event
    side-effects:
        An acknoledgement is sent to the customer,
        along with the booked cargo.

data Cargo =
    Origin
    AND Destination
    AND ArrivalDeadline

data CargoId = ??? // Autogenerated, Visible to the customer
data Origin = Location
data Destination = Location
```

`Context: Booking-Cargo`

```text
Context: Booking-Cargo

data UnvalidatedCargo =
    UnvalidatedOrigin
    AND UnvalidatedDestination
    AND UnvalidatedArrivalDeadline

data ValidatedCargo =
    ValidatedOrigin
    AND ValidatedDestination
    AND alidatedArrivalDeadline

data Location = string starting with 2 letlers small or capital then 3 small or capital letter or digit
```

`Workflow: Book Cargo`

```text
workflow: Book Cargo
    input: BookCargoForm
    output:
        CargoBooked Event
        OR Invalid Booking Cargo

    // step 1
    do Validate Cargo
    if booking cargo is invalid then:
        return error
        stop

    // step 2
    do Booking

    // step 3
    return CargoBooked event (if no errors)

substep "ValidateCargo"
    input: UnvalidateCargo
    output: ValidatedCargo or ValidationError
    dependencies: CheckLocationExists

    check for origin and destination location syntax
    check that origin and destination exists
    ckeck that the arrival destination date is not less than today

    if everything is OK, then:
        return Validated Cargo
    else
        return ValidationError

substep "BookCargo"
    input: ValidatedCargo
    output: BookedCargo
    dependencies:

    set arrival and destination location
    set arrival destination date.

```

### Entinties

Cargo, Location

### Value Objects

Voyage Number, TrackingId

Again workflow with the types included.

```text
workflow: Book Cargo
    input: Unvalidated
    output:
        BookedCargo Event
        OR Invalid Booking Cargo

    // step 1
    do Validate Booking Cargo
    if booking cargo is invalid then:
        return error
        stop

    // step 2
    do Booking

    // step 3
    return CargoBooked event (if no errors)
```

The input of the workflow should always be a domain object.
In our case,

```fsharp
type UnvalidatedBookCargo = {
    TrackingId: string
    UnvalidatedOrigin: UnvalidatedLocation
    UnvalidatedDestination: UnvalidatedLocation
    UnvalidatedArrivalDeadline: UnvalidatedArrivalDeadline
}
```

The command should contain everything the workflow needs in order to process the request.
That's why we have `TrackingId` included.

Defining state implicity has the following problems:

- Lot's of condition logic in order to be handled.
- State has some data that other states don't need.
- Is not clear which field goes with which state.

By using a seperate type for each state, it makes it easier to add new states without breaking existing code.

data Type = ??? // Don't know yet --> Undefined = exn
